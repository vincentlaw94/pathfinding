{"version":3,"sources":["Grid/Node/Node.jsx","algorithms/utility.js","algorithms/dijkstra.js","algorithms/uninformedSearch.js","algorithms/astar.js","Header/NavigationBar.jsx","Grid/Grid.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","type","onMouseDown","onMouseEnter","onMouseUp","id","className","extraClassName","React","Component","getAllNodes","grid","nodes","node","push","getUnvisitedNeighbors","neighbors","length","filter","neighbor","isVisited","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","unvisitedNeighbors","isWeight","previousNode","bfs","startNode","finishNode","visitedNodesInOrder","queue","explored","Set","currentNode","shift","isWall","has","add","sortNodeByCost","mdCost","manhantanDisance","Math","abs","NavigationBar","state","pathfindingAlgo","alert","onVisiualizePressed","fixed","onClearPathPressed","wallWeightToggle","Menu","inverted","style","backgroundColor","Container","Item","as","header","Image","size","marginRight","Dropdown","item","text","onClick","setState","position","Button","color","visualizedPress","margin","List","horizontal","Message","content","Grid","handleKey","e","keyCode","keyEvent","createRef","width","height","mouseIsPressed","startIsPressed","finishIsPressed","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","initiateGrid","current","addEventListener","focus","newGrid","document","getElementById","getNewGrid","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","pathfindAlgo","closestNode","Infinity","dijkstra","stack","pop","dfs","astar","wall","weight","pathfinding","nodesShortestPath","unshift","getNodesInShortestPathOrder","animatePathfinding","visualizePathfinding","clearGrid","tabIndex","ref","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","isStart","handleMouseUp","isFinish","currentRow","createNode","wallWeight","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7d9451b5.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Node.css\";\n\nclass Node extends React.Component {\n  \n\n  render() {\n    const { col, row, type, onMouseDown, onMouseEnter, onMouseUp } = this.props;\n\n    function extraClassName(type) {\n      switch (type) {\n        case \"START\":\n          return \"node-start\";\n        case \"FINISH\":\n          return \"node-finish\";\n        case \"WALL\":\n          return \"node-wall\";\n        case \"WEIGHT\":\n            return \"node-weight\"\n        default:\n          return \"\";\n      }\n    }\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName(type)}`}\n        onMouseDown={() => onMouseDown(row, col, type)}\n        onMouseEnter={() => onMouseEnter(row, col, type)}\n        onMouseUp={() => onMouseUp()}\n        \n      />\n    );\n  }\n}\n\nexport default Node;\n","export function getAllNodes(grid){\n    const nodes = [];\n    for (const row of grid){\n        for (const node of row){\n            nodes.push(node)\n        }\n    }\n    return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) { \n    const nodesShortestPath = [];\n    let currentNode = finishNode\n    while (currentNode !== null ) {\n        nodesShortestPath.unshift(currentNode)\n        currentNode = currentNode.previousNode\n    }\n    return nodesShortestPath\n}\n\nexport function getUnvisitedNeighbors(node, grid){\n    const neighbors = [];\n    const {row, col} = node;\n    if (row > 0) neighbors.push(grid[row-1][col])\n    if (row < grid.length -1) neighbors.push(grid[row + 1][col])\n    if (col > 0) neighbors.push(grid[row][col-1])\n    if (col <grid[0].length -1) neighbors.push(grid[row][col + 1])\n    return neighbors.filter(neighbor => !neighbor.isVisited)\n}\n\n","//perform dijkstra algo\n//use priority queue for the shortest distance \nimport {getAllNodes, getUnvisitedNeighbors} from './utility'\n\n\nexport function dijkstra(grid, startNode, finishNode){\n    const visitedNodesInOrder = [];\n    startNode.distance = 0; \n    const unvisitedNodes = getAllNodes(grid);\n    while(unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes)\n        const closestNode = unvisitedNodes.shift();\n        if (closestNode.isWall) continue;\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        closestNode.isVisited = true; \n        visitedNodesInOrder.push(closestNode)\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid)\n     }\n}\n\nfunction sortNodesByDistance(unvisitedNodes){\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n}\n\nfunction updateUnvisitedNeighbors(node, grid){\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid)\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = neighbor.isWeight? node.distance + 2  :node.distance + 1 \n        neighbor.previousNode = node\n    }\n}\n\n\n\n\n\n","//dfs, bfs \nimport {getUnvisitedNeighbors} from './utility'\n\nexport function bfs(grid,startNode,finishNode){\n    const visitedNodesInOrder = [];\n    const queue = [];\n    const explored = new Set()\n    queue.push(startNode)\n    \n    while (queue.length){\n        const currentNode = queue.shift()\n        if (currentNode.isWall || explored.has(currentNode)) continue;\n        currentNode.isVisited  = true;\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === finishNode) return visitedNodesInOrder;\n        explored.add(currentNode)\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid)\n        for (const neighbor of unvisitedNeighbors){\n            neighbor.previousNode = currentNode \n            queue.push(neighbor)\n        }\n    }\n}\n\nexport function dfs(grid, startNode, finishNode){\n    const visitedNodesInOrder = [];\n    const stack = [];\n    const explored = new Set();\n    stack.push(startNode)\n    while(stack.length){\n        const currentNode = stack.pop()\n        if (currentNode.isWall || explored.has(currentNode)) continue;\n        visitedNodesInOrder.push(currentNode)\n        currentNode.isVisited = true\n        if(currentNode === finishNode) return visitedNodesInOrder\n        explored.add(currentNode)\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid)\n        for (const neighbor of unvisitedNeighbors){\n            neighbor.previousNode = currentNode\n            stack.push(neighbor)\n        }\n    }\n}\n\n","import { getUnvisitedNeighbors, getAllNodes } from \"./utility\";\n\n// astar with manhattan distance heuristic\n\nexport function astar(grid, startNode, finishNode){\n    const visitedNodesInOrder = [];\n    \n    const unvisitedNodes = getAllNodes(grid);\n    startNode.distance = 0 \n    while(unvisitedNodes.length){\n        sortNodeByCost(unvisitedNodes)\n        const closestNode = unvisitedNodes.shift()\n        if (closestNode.isWall) continue\n        if (closestNode.distance === Infinity) return visitedNodesInOrder\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode)\n        if (closestNode===finishNode) return visitedNodesInOrder\n        updateUnvisitedNeighbors(closestNode, finishNode, grid)\n    }\n}\n\nfunction sortNodeByCost(unvisitedNodes){\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance)\n}\n\nfunction updateUnvisitedNeighbors(node, finishNode, grid){\n    const unvisitedNeighbors = getUnvisitedNeighbors(node,grid)\n    for (const neighbor of unvisitedNeighbors){\n        const mdCost = manhantanDisance(neighbor, finishNode)\n        neighbor.distance = neighbor.isWeight? node.distance + 2 + mdCost :node.distance + 1 + mdCost\n        \n        \n        neighbor.previousNode = node\n    }\n}\n\nfunction manhantanDisance(node, finishNode){\n    return Math.abs(finishNode.row - node.row) + Math.abs(finishNode.col - node.col)\n}","import React, { Component } from \"react\";\nimport {\n  Container,\n  Message,\n  Dropdown,\n  Grid,\n  Header,\n  Image,\n  List,\n  Menu,\n  Button,\n  Segment\n} from \"semantic-ui-react\";\nimport Node from \"../Grid/Node/Node.jsx\";\nexport default class NavigationBar extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      pathfindingAlgo: \"\"\n    };\n  }\n\n  visualizedPress() {\n    if (this.state.pathfindingAlgo === \"\") {\n      alert(\"Please select pathfinding algorithm first.\");\n    } else {\n      this.props.onVisiualizePressed(this.state.pathfindingAlgo);\n    }\n  }\n  render() {\n    const { fixed } = this.state;\n    const { onClearPathPressed, wallWeightToggle } = this.props;\n    return (\n      <div>\n        <Menu fixed=\"top\" inverted style={{ backgroundColor: \"#061830\" }}>\n          <Container>\n            <Menu.Item as=\"a\" header>\n              <Image size=\"mini\" style={{ marginRight: \"1.5em\" }} />\n              Pathfinding Visualizer\n            </Menu.Item>\n\n            <Dropdown item text={\"Algorithm\"}>\n              <Dropdown.Menu>\n                <Dropdown.Item\n                  onClick={() => this.setState({ pathfindingAlgo: \"DFS\" })}\n                >\n                  Depth First Search\n                </Dropdown.Item>\n                <Dropdown.Item\n                  onClick={() => this.setState({ pathfindingAlgo: \"BFS\" })}\n                >\n                  Breath First Search\n                </Dropdown.Item>\n                <Dropdown.Item\n                  onClick={() => this.setState({ pathfindingAlgo: \"Dijkstra\" })}\n                >\n                  Dijkstra\n                </Dropdown.Item>\n                <Dropdown.Item\n                  onClick={() => this.setState({ pathfindingAlgo: \"A*\" })}\n                >\n                  A* Search\n                </Dropdown.Item>\n              </Dropdown.Menu>\n            </Dropdown>\n            <Dropdown item text=\"Generate Maze\">\n              <Dropdown.Menu>\n                <Dropdown.Item>List Item</Dropdown.Item>\n                <Dropdown.Item>List Item</Dropdown.Item>\n              </Dropdown.Menu>\n            </Dropdown>\n            <Menu.Item position=\"right\">\n              <Button\n                color=\"blue\"\n                style={{ marginRight: 16 }}\n                onClick={() => this.visualizedPress()}\n              >\n                Visualize {this.state.pathfindingAlgo}!\n              </Button>\n              <Button onClick={() => onClearPathPressed()}>Clear Grid</Button>\n            </Menu.Item>\n          </Container>\n        </Menu>\n        <Container style={{ margin: 50 }}>\n          <List horizontal>\n            <List.Item>\n              <Node\n                onMouseDown={() =>{}}\n                onMouseEnter={()=>{}}\n                onMouseUp={() => {}}\n                type=\"START\"\n              />\n              Start Node\n            </List.Item>\n            <List.Item>\n              <Node\n                onMouseDown={() =>{}}\n                onMouseEnter={()=>{}}\n                onMouseUp={() => {}}\n                type=\"FINISH\"\n              />\n              Finish Node\n            </List.Item>\n            <List.Item>\n            <Node\n                onMouseDown={() =>{}}\n                onMouseEnter={()=>{}}\n                onMouseUp={() => {}}\n                type=\"WEIGHT\"\n              />\n              Weight Node\n            </List.Item>\n            <List.Item>\n            <Node\n                onMouseDown={() =>{}}\n                onMouseEnter={()=>{}}\n                onMouseUp={() => {}}\n                type=\"WALL\"\n              />\n              Wall Node\n            </List.Item>\n          </List>\n        </Container>\n        <Message\n          header=\"Press w to toggle between wall and weight\"\n          content={wallWeightToggle ? \"Wall\" : \"Weight\"}\n        />\n      </div>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./Grid.css\";\nimport Node from \"./Node/Node\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { bfs, dfs } from \"../algorithms/uninformedSearch\";\nimport { astar } from \"../algorithms/astar\";\nimport {\n  getNodesInShortestPathOrder,\n  getAllNodes\n} from \"../algorithms/utility\";\nimport NavigationBar from \"../Header/NavigationBar.jsx\";\n\nclass Grid extends React.Component {\n  constructor(props) {\n    super(props);\n    this.keyEvent = React.createRef();\n    this.state = {\n      width: 50,\n      height: 30,\n      grid: [],\n      mouseIsPressed: false,\n      startIsPressed: false,\n      finishIsPressed: false,\n\n      wallWeightToggle: true, //wall=true, weight=false\n      START_NODE_ROW: 10,\n      START_NODE_COL: 15,\n      FINISH_NODE_ROW: 10,\n      FINISH_NODE_COL: 35\n    };\n  }\n\n  componentDidMount() {\n    const grid = initiateGrid();\n    this.setState({ grid });\n    this.keyEvent.current.addEventListener(\"keyup\", this.handleKey);\n    this.keyEvent.current.focus();\n  }\n\n  handleKey = e => {\n    if (e.keyCode === 87) {\n      this.setState({ wallWeightToggle: !this.state.wallWeightToggle });\n    }\n  };\n  clearGrid() {\n    const {\n      width,\n      height,\n      START_NODE_COL,\n      START_NODE_ROW,\n      FINISH_NODE_COL,\n      FINISH_NODE_ROW\n    } = this.state;\n    this.setState({ grid: [] });\n    const newGrid = initiateGrid();\n    this.setState({ grid: newGrid });\n\n    for (let row = 0; row < height; row++) {\n      for (let col = 0; col < width; col++) {\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\n      }\n\n      document.getElementById(\n        `node-${START_NODE_ROW}-${START_NODE_COL}`\n      ).className = \"node node-start\";\n      document.getElementById(\n        `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\n      ).className = \"node node-finish\";\n    }\n  }\n  // mouse events: drag start/finish node, walls, and weights\n  handleMouseDown(row, col, type) {\n   \n    if (type === \"START\") {\n      this.setState({ startIsPressed: true });\n    }\n    if (type === \"FINISH\") {\n      this.setState({ finishIsPressed: true });\n    }\n    if (type === \"EMPTY\" || type === \"WEIGHT\" || type === \"WALL\") {\n      const newGrid = getNewGrid(\n        this.state.grid,\n        row,\n        col,\n        this.state.wallWeightToggle\n      );\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (this.state.startIsPressed) {\n      this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\n    }\n    if (this.state.finishIsPressed) {\n      this.setState({ FINISH_NODE_COL: col, FINISH_NODE_ROW: row });\n    }\n    if (this.state.mouseIsPressed) {\n      const newGrid = getNewGrid(\n        this.state.grid,\n        row,\n        col,\n        this.state.wallWeightToggle\n      );\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n  handleMouseUp() {\n    this.setState({\n      mouseIsPressed: false,\n      startIsPressed: false,\n      finishIsPressed: false\n    });\n  }\n\n  animatePathfinding(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (\n          node.row === this.state.START_NODE_ROW &&\n          node.col === this.state.START_NODE_COL\n        ) {\n          //do nothing\n        } else if (\n          node.row === this.state.FINISH_NODE_ROW &&\n          node.col === this.state.FINISH_NODE_COL\n        ) {\n          //do nothing\n        } else {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";}\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    \n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n\n        if (\n          node.row === this.state.START_NODE_ROW &&\n          node.col === this.state.START_NODE_COL\n        ) {\n          //do nothing\n        } else if (\n          node.row === this.state.FINISH_NODE_ROW &&\n          node.col === this.state.FINISH_NODE_COL\n        ) {\n          //do nothing\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-shortest-path\";\n        }\n      }, 50 * i);\n    }\n    document.getElementById(\n      `node-${this.state.START_NODE_ROW}-${this.state.START_NODE_COL}`\n    ).className = \"node node-start\";\n    document.getElementById(\n      `node-${this.state.FINISH_NODE_ROW}-${this.state.FINISH_NODE_COL}`\n    ).className = \"node node-finish\";\n  }\n\n  pathfinding(pathfindAlgo, grid, startNode, finishNode) {\n    switch (pathfindAlgo) {\n      case \"Dijkstra\":\n        const visitedNodesInOrderDijkstra = dijkstra(\n          grid,\n          startNode,\n          finishNode\n        );\n        return visitedNodesInOrderDijkstra;\n      //bfs, dfs, a* search\n      case \"BFS\":\n        const visitedNodesInOrderBfs = bfs(grid, startNode, finishNode);\n        return visitedNodesInOrderBfs;\n\n      case \"DFS\":\n        const visitedNodesInOrderDfs = dfs(grid, startNode, finishNode);\n        return visitedNodesInOrderDfs;\n\n      case \"A*\":\n        const visitedNodesInOrderAstar = astar(grid, startNode, finishNode);\n        return visitedNodesInOrderAstar;\n\n      default:\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n        return visitedNodesInOrder;\n    }\n  }\n\n  visualizePathfinding(pathfindingAlgo) {\n    const {\n      width,\n      height,\n      grid,\n      START_NODE_COL,\n      START_NODE_ROW,\n      FINISH_NODE_COL,\n      FINISH_NODE_ROW\n    } = this.state;\n\n    const nodes = getAllNodes(grid);\n    const wall = nodes.filter(node => node.isWall);\n    const weight = nodes.filter(node => node.isWeight);\n\n    const newGrid = initiateGrid();\n    for (const node of wall) {\n      node.previousNode = null;\n      newGrid[node.row][node.col] = node;\n    }\n    for (const node of weight) {\n      node.previousNode = null;\n      newGrid[node.row][node.col] = node;\n    }\n    this.setState({ grid: newGrid });\n\n    for (let row = 0; row < height; row++) {\n      for (let col = 0; col < width; col++) {\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\n      }\n    }\n    document.getElementById(\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\n    ).className = \"node node-start\";\n    document.getElementById(\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\n    ).className = \"node node-finish\";\n\n    for (const node of wall) {\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-wall\";\n    }\n    for (const node of weight) {\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-weight\";\n    }\n\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = this.pathfinding(\n      pathfindingAlgo,\n      grid,\n      startNode,\n      finishNode\n    );\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animatePathfinding(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  render() {\n    const {\n      grid,\n      START_NODE_COL,\n      START_NODE_ROW,\n      FINISH_NODE_COL,\n      FINISH_NODE_ROW\n    } = this.state;\n\n    return (\n      <div>\n        <NavigationBar\n          onVisiualizePressed={e => this.visualizePathfinding(e)}\n          onClearPathPressed={() => this.clearGrid()}\n          wallWeightToggle={this.state.wallWeightToggle}\n        />\n\n        <div className=\"grid\" tabIndex=\"0\" ref={this.keyEvent}>\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isWall, isWeight } = node;\n                  if (row === START_NODE_ROW && col === START_NODE_COL) {\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        onMouseDown={(row, col, type) =>\n                          this.handleMouseDown(row, col, type)\n                        }\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        isStart={true}\n                        onMouseUp={() => this.handleMouseUp()}\n                        type=\"START\"\n                        row={row}\n                      />\n                    );\n                  }\n                  if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        onMouseDown={(row, col, type) =>\n                          this.handleMouseDown(row, col, type)\n                        }\n                        onMouseEnter={(row, col, type) =>\n                          this.handleMouseEnter(row, col, type)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}\n                        isFinish={true}\n                        type=\"FINISH\"\n                      />\n                    );\n                  }\n                  if (isWall) {\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        onMouseDown={(row, col, type) =>\n                          this.handleMouseDown(row, col, type)\n                        }\n                        onMouseEnter={(row, col, type) =>\n                          this.handleMouseEnter(row, col, type)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}\n                        type=\"WALL\"\n                      />\n                    );\n                  }\n                  if (isWeight) {\n                    return (\n                      <Node\n                        key={nodeIdx}\n                        col={col}\n                        onMouseDown={(row, col, type) =>\n                          this.handleMouseDown(row, col, type)\n                        }\n                        onMouseEnter={(row, col, type) =>\n                          this.handleMouseEnter(row, col, type)\n                        }\n                        onMouseUp={() => this.handleMouseUp()}\n                        row={row}\n                        type=\"WEIGHT\"\n                      />\n                    );\n                  }\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      onMouseDown={(row, col, type) =>\n                        this.handleMouseDown(row, col, type)\n                      }\n                      onMouseEnter={(row, col, type) =>\n                        this.handleMouseEnter(row, col, type)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                      type=\"EMPTY\"\n                    />\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nconst initiateGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 30; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: false,\n    isFinish: false,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    isWeight: false,\n    previousNode: null,\n    type: \"EMPTY\"\n  };\n};\n\nconst getNewGrid = (grid, row, col, wallWeight) => {\n  if (wallWeight) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n      isWeight: false\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  }\n  if (!wallWeight) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: false,\n      isWeight: !node.isWeight\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  }\n};\n\nexport default Grid;\n","import React from 'react';\n\nimport Grid from './Grid/Grid'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n    <Grid/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App'\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}